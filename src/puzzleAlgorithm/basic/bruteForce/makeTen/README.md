# 텐퍼즐(ten puzzle): 완전 탐색

## 텐퍼즐이란?
**텐퍼즐**은 주어진 4개의 수로 사칙연산을 조합해 만들고자 하는 수(대개 10)를 만드는 퍼즐이다. 

<u>예를 들어,</u>
<br/>
1, 2, 3, 4 를 이용하여 10을 만드는 방법은 **1 + 2 + 3 + 4** 혹은 **(4 * 3) - (2 * 1)** 등이 있다.
<br/>
<br/>
<u>좀 더 어렵게 하자면,</u><br/>
1, 2, 7, 7 을 이용해 10을 만드는 방법은 **(7 - 1) / 2 + 7** 등이 있으며
<br />
<br />
<u>더더욱 어렵게 하자면,</u><br/>
1, 3, 3, 7 을 이용해 만드는 방법으로는 **(1 + 7 / 3) * 3**이 있겠다.

## 풀이 방법
사실 이 문제는 이 문제는 이론적으로 '4개의 수를 사용한 계산식'을 전부 알아 보야야 풀 수 있다. 
이처럼 생각할 수 있는 모든 경우를 알아보는 방법을 <u>**완전 탐색**(brute-force search)</u>라고 한다.

보통 문제 풀이를 할 때에 가장 간단하고도 무식한(?) 방법은 완전탐색인데, 완전탐색 알고리즘을 선택하기 전에 두 가지 사항을 고려해야 한다.
이따가 다시 이야기하겠지만, 고려해야 할 사항은 아래와 같다.
 * 생각할 수 있는 경우를 어떻게 열거할 것인가?
 * 경우의 수는 몇가지가 나오는가?
<br/>

### 역폴란드 표기법(reverse Polish notation)
일반적인 계산식은 연산자가 계산하는 숫자들 사이에 들어간다. 이렇게 말이다. => **1 + 2** <br/>
역폴란드 표기법은 연산자가 계산하는 숫자들 뒤 쪽으로 옮겨진다. 이렇게 말이다. => **12+**

역폴란드 표기법을 이용하면 두 수의 연산 뿐 아니라 복잡한 계산식도 보다 간결해진다고 한다. <br/>
**1 + 2 + 3 + 4** 계산식을 역폴란드 표기법으로 풀어본다면 아래와 같다.<br />
```
12+3+4+
```
**(4 * 3) - (2 * 1)** 계산식을 역폴란드 표기법으로 풀어본다면 아래와 같다.<br />
```
43*21*-
```
**(7 - 1) / 2 + 7** 계산식을 역폴란드 표기법으로 풀어본다면 아래와 같다.<br />
```
71-2/7+
```
**(1 + 7 / 3) * 3** 계산식을 역폴란드 표기법으로 풀어본다면 아래와 같다.
```
173/+3*
```
순서 말고 중요한 차이점이 보이는가, **계산식에서 괄호가 필요 없어졌다!**<br/>
텐게임에 필요한 숫자는 4개이며 연산자는 3개가 필요하다. 괄호가 필요 없어졌으니 어떠한 계산식이든 모두 7글자로 이루어진다.

좋다. 우리는 이렇게 해볼 것이다.<br/>
예를 들어, **"12+3+4+"** 라는 계산식이 들어온다면 앞에서부터 한글자씩 읽어들여서 문자가 숫자라면 배열 말미에 삽입하고, 연산자가 들어온다면
배열 맨 뒤 두 숫자를 "꺼내서" 해당 연산자에 따라 계산한 후 다시 배열의 맨 뒤에 삽입할 것이다.<br/>
맨 마지막에 남은 숫자 하나가 바로 계산 결과이다.<br/>
구현 코드는 역폴란드 표기법으로 계산된 수식을 계산하는 함수인 <u>**calcPoland()**</u>를 참고하기 바란다.<br/>

## 완전탐색 시 고려사항
앞서 말했다시피 보통 문제 풀이를 할 때에 가장 간단하고도 무식한(?) 방법은 완전탐색이다.<br />
<u>하지만 과연 일일히 모든 경우의 수를 조합하는 이 방법이 효율적일까?</u>

### 컴퓨터의 계산 능력
일반적으로 문제를 푸는 알고리즘을 판단하려면 컴퓨터의 계산 능력을 알아야 한다.<br/>
평범한 가정용 컴퓨터를 사용할 경우, <u>1초 동안 처리 가능한 계산 스텝횟수는 **약 10억 회**</u>라고 한다.

아래의 코드를 보면 10억 번 동안 i < 1000000000 인지 판단하는 처리와 i++ 갱신처리 2회의 연산을 반복 한다.<br/>
요즘은 하드웨어의 성능이 많이 좋아져서 그런지 20억 회의 연산을 하는 데에 10 밀리세컨드 조차 걸리지 않음을 확인할 수 있었다.
``` java
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        for(int i = 0; i < 1000000000; i++){
        }
        long endTime = System.currentTimeMillis();
        long secDiffTime = endTime - startTime;
        // it won't take more than 10 milliseconds to operate two billion steps
        System.out.println("secDiffTime : " + secDiffTime);
    }
```

요는 이것이다. <b><u>컴퓨터는 1초 동안 약 10억 회 계산은 거뜬하다.</u></b>

### 텐게임에서 생각할 수 있는 계산식 개수
위에서 우리는 계산식을 어떻게 나열할 것인지에 대해 역폴란드 표기법을 사용할 것이라고 말했다.<br/>

역폴란드 표기법을 사용했을 때의 장점은 4개의 숫자와 4개의 연산자의 배치 패턴을 열거하는데 5가지 패턴밖에 없다는 것이다.<br/>
x는 0부터 9까지의 숫자 중 하나를 의미하고, o는 4개의 연산자 중 하나를 표현한다. 숫자는 총 4번, 연산자는 총 3번 등장한다.

1. **xxxxooo** : ex) 8115/-/ => 8 / (1 - 1 / 5)
2. **xxxoxoo** : ex) 634*8-+ => 3 * 4 - 8 + 6
3. **xxxooxo** : ex) 173/+3* => (1 + 7 / 3) * 3
4. **xxoxxoo** : ex) 43\*21\*- => (4 * 3) * (2 * 1)
5. **xxoxoxo** : ex) 12+3+4+ => 1 + 2 + 3 + 4

예를 들어 'xoxoxoo' 등은 계산식으로 성립하지 않는다. 그 이유도 생각해보면 좋을 것이다.

나열할 수 있는 계산식의 윤곽이 어느정도 잡힌 것 같다.<br />
5가지의 패턴 * 4개의 수를 나열하는 순서 경우의 수 24가지(4 * 3 * 2 * 1) * 3 연산자 종류 경우의 수 64가지 (4 * 4 * 4)<br/>
**<u>그래서 최대 7680개의 경우의 수가 등장한다.</u>**<br />
더군다가 '1+2'와 '2+1'은 동일하기 때문에 실질적인 경우의 수는 감소하게 된다.

### 완전탐색 알고리즘과 텐게임
앞서 살펴보았듯이 컴퓨터의 1초 동안 10번 이상의 연산을 할 수 있다. 
그리고 텐게임에서 나열할 수 있는 모든 경우의 수는 최대 7680개이다.
<br />
1가지 선택지에서 연산이 100번 일어난다고 가정했을 때에 컴퓨터는 1초동안 1천만 가지의 선택지를 살펴보게 된다.
텐게임의 최대 경우의 수는 7680번이므로 모든 선택지를 살펴본다고 해도 1초도 채 걸리지 않음을 알 수 있다.
<br /> 알고리즘 계산 시간을 예상하는 **시간 복잡도 계산량 표기** 라는 것이 있는데 이것은 나중에 살펴보도록 하자.

## 구현
주어진 4개의 수로 만들조가 하는 수를 만드는 프로그램을 만들어보자.
앞서 이야기했듯, '4개의 수 순서'와 '3개의 연산자 종류'와 5가지의 계산식 패턴을 모두 탐색하자.<br />
<u>**solve()**</u> 메소드를 확인하기 바란다.

## 정리
텐퍼즐에서는 생각할 수 있는 모든 경우의 수를 살펴보도록 완전탐색 알고리즘을 선택했다.
완전탐색 알고리즘을 설계할 때에는 두가지를 검토해야한다고 말했다.
* 생각할 수 있는 경우를 어떻게 열거할 것인가?
* 경우의 수는 몇가지가 나오는가?

이번에는 역폴란드 표기법을 활용하여 계식식 열거 과정이 비교적 간소화 되었다. 
또한 생각할 수 있는 경우의 수가 최대 7680 가지로 1억에 비해 매우 적다는 사실도 중요하게 작용하였다.<br/>
하지만 만약 경우의 수가 훨씬 더 많아질 경우 고급 알고리즘이 필요하다.
앞으로 다룰 문제들에서는 경우의 수가 많아서 완전탐색으로는 풀 수가 없다. 그렇기 때문에 어떤 알고리즘을 선택할 것인가가 중요하다.
<br /><br />
**그럼에도 불구하고** 문제를 풀 때에는 완전탐색 알고리즘을 먼저 고려하는 것이 중요하다. 
이를 통해 동적 계산법 같은 고급 알고리즘 설계로 이어지는 사례도 많기 때문이다.